"""
Задание 1 "IP-адреса"
	IpV4 адрес состоит из 4 октетов, значит его можно хранить в переменной типа int32.
	Реализуйте пару функций, которые однозначно преобразуют строковое представление IpV4 адрес
	(вида "127.0.0.1") в значение типа int32 и наоборот.
	Примеры:
	2149583360 ==> "128.32.10.0"
	255        ==> "0.0.0.255"
"""


def ip_to_code(ip):
    """
    Каждый октет IP-адреса заключает в себе 256 комбинаций предыдущего октета.
    Так, третий октет содержит в себе 256 комбинаций четвёртого октета, а второй -
    256 комбинаций третьего, каждый из которого содержит в себе, в свою очередь, еще по 256 комбинаций
    четвёртого октета. В четвёртом же октете комбинация содержится только одна - та, которую мы там и видим.
    Таким образом, четвёртый октет содержит 1 комбинацию, или 256^0,
    третий октет содержит 256(или 256^1) комбинаций,
    второй - 256*256(256^2), а первый - 256*256*256(256^3) комбинаций адресов.
    Формула перевода IP в число - Х = У*256^3+Y*256^2+Y*256*1+Y*256^0.
    Код можно доработать - добавить проверку, чтобы приходила строка определенного формата и
    содержала только цифры. В более новых версиях адресов уже используются и буквы, что усложняет проверки.
    """
    # разбить адрес на блоки по разделителю
    list_digits = ip.split('.')
    # переменная, которая будет хранить в себе полученное число
    ip_number = 0
    # длина полученного списка (чтобы не хардкодить лишний раз, но можно задать напрямую)
    list_len = len(list_digits) - 1
    # переменная i отвечает за возведение в степень. Степеней 4 - от 3 до 0.
    # при желании можно опустить последний цикл, любое число в степени 0 даст 1.
    # тогда цикл переделывается, используем for j in range(0,list_len-1), а после цикла отдельно прибавим число октета.
    i = list_len
    for j in list_digits:
        ip_number += int(j) * pow(256, i)
        i -= 1
    return ip_number


def ip_from_code(ip_code):
    # список, куда будем поэтапно вычленять наш IP-адрес
    list_digits = []
    # октетов в IP четыре, значит пройдемся четыре раза по числовому коду адреса.
    # выделяем остаток от деления на 256 - это наш искомый октет
    # вычтем его из числового представления IP-адреса и разделим на 256 - получили число оставшихся первых трех октетов.
    # повторим операции, пока не найдем самый первый октет.
    for i in range(0, 4):
        number = int(ip_code % 256)
        list_digits.append(str(number))
        ip_code -= number
        ip_code /= 256
    # разворачиваем список - первое число становится последним, как и должно быть
    list_digits.reverse()
    ip_string = '.'.join(list_digits)
    return ip_string


code = ip_to_code(input("Введите IP адрес"))
print(code)
print(ip_from_code(code))

# другой способ, с циклом while:
# j = 0
# while j <= list_len:
#     # i будет степенью, в которую мы будем возводить основание 256. Первоначально оно равно длине списка минус 1
#     # и далее уменьшается
#     # j будет последовательным номером элемента в списке, начиная с 0
#     ip_number += int(ip_to_list[j]) * pow(256, i)
#     j += 1
#     i -= 1
# print(ip_number)
